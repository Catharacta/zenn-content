---
title: "Tauriで六角形のアプリ起動ランチャーを開発した話"
emoji: "🛑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Tauri","Rust","TypeScript","個人開発",]
published: true
---

# 背景

六角形のセルにショートカットを登録して起動することができるランチャーを作りました。
![](/images/9d752d6d5757a7/top.png)

- 起動するとタスクトレイに常駐し、ショートカットキー(デフォルトはAlt+Space)、もしくはタスクトレイメニューからランチャーを表示します。
- ランチャーはフルスクリーンウインドウの中に表示され、背景ウインドウを透明にすることで、六角形のセルのみを表示しています。
- 六角形の各セルにドラッグアンドドロップでショートカットを登録できます。
- ショートカットを登録したセルをクリックすると、ショートカットが起動します。
- Windows用
- Insertキーを押すとセル追加モードになり、空いている場所にセルを追加することができます。
- 設定でCyeberPunk Modeを選択すると、マウスホバーしたセルがグリッチして、背景にCRTとパーティクルが表示されます。


以下のサイトからダウンロードできます。
https://catharacta.github.io/hexa-launcher-web/


# 背景

六角形セル型のランチャーは Rainmeter のスキンとして既に存在します。

https://forum.rainmeter.net/viewtopic.php?t=45447

ただし Rainmeter 版はセルの配置が固定で、利用には Rainmeter のインストールが必要になります。そこで、セルを自由に配置でき、スタンドアロンで動作するランチャーを作ることにしました。

# 設計・実装のポイント（技術的見どころ）

実装で特に工夫した2つのポイントを紹介します。

### 六角形グリッドの実装

六角形グリッドを実装するうえで最初に決めなければならないのが 座標系 です。

| 座標系 | 特徴 |
|---|---|
| Offset座標 | 行/列で管理。直感的だが計算が複雑 |
| Axial座標 | 2軸 (q, r) で管理。シンプルだが制約が必要 |
| Cube座標 | 3軸 (x, y, z) で管理。冗長だが計算が最も簡単 |

本ソフトウェアでは Cube座標 を採用しました。理由は以下の通りです：

- 隣接セルの計算がシンプル — 方向ベクトルを足すだけ
- 距離計算が容易 — マンハッタン距離の半分
- 回転・反転が対称的 — アルゴリズムが書きやすい

```js
// Cube座標の型定義
interface Cube {
    x: number;
    y: number;
    z: number;
}
// 制約: x + y + z = 0 を常に満たす
```

#### 6方向の移動

Cube座標では、6方向の移動は単純なベクトル加算で表現できます：
```js
const CUBE_DIRECTIONS: Cube[] = [
    { x: +1, y: -1, z:  0 }, // E  (東)
    { x: +1, y:  0, z: -1 }, // NE (北東)
    { x:  0, y: +1, z: -1 }, // NW (北西)
    { x: -1, y: +1, z:  0 }, // W  (西)
    { x: -1, y:  0, z: +1 }, // SW (南西)
    { x:  0, y: -1, z: +1 }, // SE (南東)
];
// 隣接セルを取得
function getNeighbor(cube: Cube, direction: number): Cube {
    const dir = CUBE_DIRECTIONS[direction];
    return {
        x: cube.x + dir.x,
        y: cube.y + dir.y,
        z: cube.z + dir.z,
    };
}
```

図にすると以下のようになります(上がN)
![](/images/9d752d6d5757a7/hexagon_news.png)

#### ピクセル座標への変換

Cube座標から実際の描画位置（ピクセル座標）への変換は、Pointy-topped（頂点が上）レイアウトの数式を使います
```js
function cubeToPixel(cube: Cube, size: number): Point {
    const x = size * Math.sqrt(3) * (cube.x + cube.z / 2);
    const y = size * (3 / 2) * cube.z;
    return { x, y };
}
```

この変換により、Cube座標 {0, 0, 0} を中心として、リング状にセルを配置できます。

#### キーボード操作のマッピング

6方向移動をキーボードにマッピングする際、以下のような配置にしました
![](/images/9d752d6d5757a7/hexagon_qwaszx.png)

```js
const KEY_TO_DIRECTION: Record<string, number> = {
    's': 0,     // E
    'w': 1,     // NE
    'q': 2,     // NW  
    'a': 3,     // W
    'z': 4,     // SW (または Q の下段)
    'x': 5,     // SE (または E の下段)
};
```

> **Tip:** 六角形グリッドの実装については、 以下の記事を参考にしました。

https://www.redblobgames.com/grids/hexagons/

### マウスエッジ起動の実装

画面の端（上端または左端）にマウスカーソルを持っていくと、ランチャーが自動的に表示される機能です。ホットキーを押さなくても起動できます。

```
┌─────────────────────────────┐
│←5px→                        │  ← この領域にカーソルが入ると起動
│  ┌───────────────────────┐  │
│  │                       │  │
│  │      デスクトップ      │  │
│  │                       │  │
│  └───────────────────────┘  │
└─────────────────────────────┘
```
実装のポイントは以下の3つです：

 - 常時監視スレッド — Rust側でマウス座標を100msごとにポーリング
 - マルチモニター対応 — 各モニターの端を個別に判定
 - 連続起動防止 — 一度起動したら1秒間はクールダウン

Rust実装
```rust
use std::thread;
use std::time::Duration;
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
pub struct MouseEdgeMonitor {
    running: Arc<Mutex<bool>>,
}
impl MouseEdgeMonitor {
    pub fn start(&self, app_handle: AppHandle) {
        let running = Arc::clone(&self.running);
        
        thread::spawn(move || {
            loop {
                // 監視フラグをチェック
                if !*running.lock().unwrap() {
                    break;
                }
                unsafe {
                    let mut point = std::mem::zeroed();
                    if GetCursorPos(&mut point).is_ok() {
                        let mouse_x = point.x;
                        let mouse_y = point.y;
                        // 各モニターをチェック
                        for monitor in app_handle.available_monitors().unwrap() {
                            let pos = monitor.position();
                            let size = monitor.size();
                            // カーソルがこのモニター内にあるか
                            let in_monitor = mouse_x >= pos.x 
                                && mouse_x < pos.x + size.width as i32
                                && mouse_y >= pos.y 
                                && mouse_y < pos.y + size.height as i32;
                            if in_monitor {
                                // 上端または左端にあるか（閾値5px）
                                let is_top = (mouse_y - pos.y).abs() <= 5;
                                let is_left = (mouse_x - pos.x).abs() <= 5;
                                if is_top || is_left {
                                    show_window(&app_handle, &monitor);
                                    // 連続起動防止
                                    thread::sleep(Duration::from_millis(1000));
                                }
                                break;
                            }
                        }
                    }
                }
                thread::sleep(Duration::from_millis(100));
            }
        });
    }
}
```

#### フォーカス奪取

Windowsでは、バックグラウンドのウィンドウが勝手に前面に来ることを防ぐ仕組みがあります。そのため、単に show() と set_focus() を呼ぶだけではフォーカスを奪えないことがあります。
この問題を解決するために、一瞬だけ always_on_top を有効にすることで、確実にフォーカスを奪うことができます。
```rust
fn show_window(app_handle: &AppHandle, monitor: &Monitor) {
    let window = app_handle.get_webview_window("main").unwrap();
    
    // 1. ウィンドウを表示
    window.show();
    window.maximize();
    
    // 2. 一時的に最前面に設定することでフォーカスを奪取
    window.set_always_on_top(true);
    window.set_focus();
    window.set_always_on_top(false);  // すぐに解除
}
```
#### なぜ100msポーリング？
ポーリング間隔を100msにした理由：

短すぎる（10ms） — CPU使用率が上がる
長すぎる（500ms） — 反応が遅く、ユーザーがイライラする
100ms — 体感的に「すぐ反応する」と感じつつ、CPU負荷は最小限

> **Tip:** マウスフックを使えばポーリングなしで実装できますが、グローバルフックはセキュリティソフトに検知されることがあるため、ポーリング方式を採用しました。

# 苦労した点・ハマったポイント
### 設定画面のフリーズ問題
問題: 配布版のexeを実行すると、設定画面を開いた瞬間にフリーズする。

開発環境では問題なく動作していたのに、ビルドしたexeを配布して実行すると、設定画面が数秒間固まる現象が発生しました。特に「起動時に自動起動」のトグルがある画面で顕著でした。

#### 原因1: 同期的な外部プロセス呼び出し
Rust側で、Windowsのスタートアップ登録状態を確認するために reg コマンドを同期的に呼び出していました。
```rust
// ❌ 問題のあるコード
#[tauri::command]
fn get_startup_status() -> Result<bool, String> {
    // reg コマンドを同期実行 → メインスレッドをブロック
    let output = std::process::Command::new("reg")
        .args(["query", "HKCU\\Software\\..."])
        .output()
        .map_err(|e| e.to_string())?;
    // ...
}
```

開発環境では高速に完了していたこの処理が、配布環境ではウイルス対策ソフトやOSの保護機能の介入により、プロセス生成に時間がかかるようになっていました。

解決策: 非同期コマンドに変更し、UI側ではOptimistic UIパターンを採用。
```rust
// ✅ 非同期に変更
#[tauri::command]
async fn get_startup_status() -> Result<bool, String> {
    tokio::task::spawn_blocking(|| {
        // ブロッキング処理をバックグラウンドスレッドで実行
        std::process::Command::new("reg")
            .args(["query", "HKCU\\Software\\..."])
            .output()
    }).await
    .map_err(|e| e.to_string())?
    // ...
}
```

```js
// フロント側: Optimistic UI
const [startupEnabled, setStartupEnabled] = useState(
  general.startOnBoot ?? false  // 保存済みの値をまず表示
);
// バックグラウンドで実際の状態を確認
useEffect(() => {
  getStartupStatus().then(setStartupEnabled);
}, []);
```

#### 原因2: 設定保存の過剰な呼び出し
フロント側の状態管理（Zustand）で、状態が更新されるたびに全設定をシリアライズして保存していました。スライダーを動かすだけで、毎フレーム大量のデータがnative invoke経由で送信されていました。

```js
// ❌ 問題のあるコード
set((state) => {
  const newState = { ...state, opacity: value };
  saveSettings(newState);  // 毎回呼ばれる
  return newState;
});
```

解決策: デバウンスを導入し、連続した変更をまとめて1回の保存に。

```js
// ✅ デバウンスで最適化
const debouncedSave = debounce((state) => {
  saveSettings(state);
}, 1000);  // 1秒間変更がなければ保存
set((state) => {
  const newState = { ...state, opacity: value };
  debouncedSave(newState);  // 連続変更は間引かれる
  return newState;
});
```

### 教訓
| 問題 | 解決策 |
|---|---|
| 同期的な外部プロセス呼び出し | `spawn_blocking` で非同期化 |
| 配布環境でのみ遅い | AV/OS保護の影響を考慮した設計 |
| 状態更新ごとの保存 | デバウンスで間引き |
| 全データのシリアライズ | 差分更新の検討（未実装） |

> **Tip:** 開発環境と配布環境の違いに注意

開発時は問題なく動作していても、配布版では以下の理由で遅くなることがあります：

- ウイルス対策ソフトによるプロセス監視
- SmartScreen / Windows Defender の検証
- 初回起動時のJITコンパイル等

外部プロセス呼び出しやファイルI/Oは、必ず非同期で行うべきです。

# 所感

本ランチャー はデザイン性を優先して作りました。

既存のWindowsランチャー（CLaunch、Flow Launcher、ueli、PowerToys Run）やスタートメニューは、機能面で非常に成熟しています。これらと正面から機能で競うのは難しい——そう判断し、差別化はUI/見た目に振る方針を取りました。

六角形グリッドという見た目のインパクト、Cyberpunkテーマのようなビジュアルエフェクト。「使っていて楽しい」と感じてもらえるランチャーを目指しています。

とはいえ機能を無視しているわけではありません。設定画面の各項目にワンクリックでアクセスできるショートカットなど、実用性を補完する仕組みも用意しています。
![](/images/9d752d6d5757a7/select_setting.png)


# まとめ

何かあれば、以下のサポートからお願いします。時間があれば対応するかもしれません。
https://catharacta.github.io/hexa-launcher-web/